pragma language_version >= 0.12.1;

import CompactStandardLibrary;

// fire/ice can go past block
// physical doesn't
// you can either be neutral (fire/ice do normal damage) or you can have higher/lower resistances to them
// do we want them to all be 1 to 10 or just {weak fire, strong ice}/{balanced}/{strong fire, weak ice}?

export enum EFFECT_TYPE {
    attack_phys,
    attack_fire,
    attack_ice,
    block,
    generate,
}

export struct Effect {
    effect_type: EFFECT_TYPE,
    // damage for attacks, defense for blocks, type of energy for generation
    amount: Uint<32>,
    is_aoe: Boolean,
}

export struct Ability {
    effect: Maybe<Effect>,
    on_energy: Vector<3, Maybe<Effect>>,
}

export struct EnemyStats {
    hp: Uint<32>,
    physical_def: Uint<32>,
    fire_def: Uint<32>,
    ice_def: Uint<32>,
}

// TODO: move into an instanced battle data (unless we can compose contracts)
export ledger enemy_damage_0: Uint<32>;
export ledger enemy_damage_1: Uint<32>;
export ledger enemy_damage_2: Uint<32>;
export ledger enemy_block_0: Uint<32>;
export ledger enemy_block_1: Uint<32>;
export ledger enemy_block_2: Uint<32>;
export ledger enemy_hp_0: Uint<32>;
export ledger enemy_hp_1: Uint<32>;
export ledger enemy_hp_2: Uint<32>;

export ledger player_damage_0: Uint<32>;
export ledger player_damage_1: Uint<32>;
export ledger player_damage_2: Uint<32>;
export ledger player_block_0: Uint<32>;
export ledger player_block_1: Uint<32>;
export ledger player_block_2: Uint<32>;
export ledger player_hp_0: Uint<32>;
export ledger player_hp_1: Uint<32>;
export ledger player_hp_2: Uint<32>;

constructor() {
    enemy_hp_0 = 0;
    enemy_hp_1 = 0;
    enemy_hp_2 = 0;
    player_hp_0 = 0;
    player_hp_1 = 0;
    player_hp_2 = 0;
}

witness player_secret_key(): Bytes<32>;

export pure circuit derive_player_pub_key(sk: Bytes<32>): Field {
    return transient_commit<Bytes<32>>(sk, 1024);
}

ledger rand_hack: Uint<32>;
circuit mock_rand_target(): Uint<0..3> {
    rand_hack = (rand_hack + 1) as Uint<32>;
    if (rand_hack > 2) {
        rand_hack = 0;
    }
    return rand_hack as Uint<0..3>;
}

// indexed by user ID then by battle ID (TODO: look up proof invalidation - are other players insulated from this by first indexing by user ID?)
export ledger active_battles: Map<Field, Map<BattleConfig, BattleState>>;

export struct Player {
    gold: Uint<32>,
    // TODO: more
}
export ledger players: Map<Field, Player>;

export struct BattleRewards {
    gold: Uint<32>;
    // what else?
}

export struct BattleConfig {
    stats: Vector<3, EnemyStats>,
    enemy_count: Uint<0..3>,
    player_layout_commit: Field,
}

export pure circuit derive_battle_id(battle: BattleConfig): Field {
    // TODO: swap to persistent?
    return transient_commit<BattleConfig>(battle, 0);
}

export struct BattleState {
    deck_i: Uint<32>;
    deck_map: Vector<7, Uint<32>>;
    player_hp_0: Uint<32>;
    player_hp_1: Uint<32>;
    player_hp_2: Uint<32>;
    enemy_hp_0: Uint<32>;
    enemy_hp_1: Uint<32>;
    enemy_hp_2: Uint<32>;
}

circuit draw_ability(battle: BattleConfig, abilities: Vector<7, Ability>): Ability {
    const old_state = active_battles.lookup(disclose(derive_player_pub_key(player_secret_key()))).lookup(battle);
    if (old_state.deck_i == 7) {
        shuffle(battle);
    }
    const i = active_battles.lookup(disclose(derive_player_pub_key(player_secret_key()))).lookup(battle).deck_i;
    return abilities[0];
}

circuit shuffle(battle: BattleConfig): [] {
    const old_state = active_battles.lookup(disclose(derive_player_pub_key(player_secret_key()))).lookup(battle);
    active_battles.lookup(disclose(derive_player_pub_key(player_secret_key()))).insert(battle, BattleState {
        3, // TODO: randomize
        [2, 3, 4, 5, 6, 0, 1],// TODO: randomize
        old_state.player_hp_0,
        old_state.player_hp_1,
        old_state.player_hp_2,
        old_state.enemy_hp_0,
        old_state.enemy_hp_1,
        old_state.enemy_hp_2
    });
}

export struct PlayerLoadout {
    abilities: Vector<7, Ability>,
}

export pure circuit derive_loadout_id(loadout: PlayerLoadout): Field {
    // this line adds ~3k to the circuit
    return transient_commit<PlayerLoadout>(loadout, 100);
    //return 0 as Field;
}

export circuit start_new_battle(loadout: PlayerLoadout): BattleConfig {
    // TODO: randomize
    const battle = BattleConfig {
        [
            EnemyStats { 30, 8, 5, 3 },
            EnemyStats { 25, 3, 8, 5 },
            EnemyStats { 20, 5, 3, 8 }
        ],
        3,
        derive_loadout_id(loadout)
    };
    player_block_0 = 0;
    active_battles.lookup(disclose(derive_player_pub_key(player_secret_key()))).insert(battle, init_battlestate(battle));
    return battle;
}

pure circuit init_battlestate(battle: BattleConfig): BattleState {
    return BattleState {
        0,
        // TODO: randomize
        [0, 5, 2, 3, 4, 1, 6],
        100,// TODO: source from somewhere - also do we want multiple people?
        100,
        100,
        battle.stats[0].hp,
        battle.stats[1].hp,
        battle.stats[2].hp
    };
}

export circuit combat_round(loadout: PlayerLoadout, battle: BattleConfig): Maybe<BattleRewards> {
    // TODO: how to cycle through abilities?
    const result = combat_round_impl(battle, [draw_ability(battle, loadout.abilities), draw_ability(battle, loadout.abilities), draw_ability(battle, loadout.abilities)], mock_rand_target());
    active_battles
        .lookup(disclose(derive_player_pub_key(player_secret_key())))
        .insert(battle, result);
    if (result.player_hp_0 == 0 && result.player_hp_1 == 0 && result.player_hp_2 == 0) {
        // TODO: how to handle 
    } else if (result.enemy_hp_0 == 0 && result.enemy_hp_1 == 0 && result.enemy_hp_2 == 0) {
        // TODO: when and how to generate?
        const reward = BattleRewards {
            100
        };
        const player_stats = players.lookup(disclose(derive_player_pub_key(player_secret_key())));
        players.insert(disclose(derive_player_pub_key(player_secret_key())), add_player_rewards(player_stats, reward));
        return some<BattleRewards>(reward);
    }
    return none<BattleRewards>();
}

pure circuit add_player_rewards(player: Player, reward: BattleRewards): Player {
    return Player {
        (player.gold + reward.gold) as Uint<32>
    };
}

circuit combat_round_impl(battle: BattleConfig, abilities: Vector<3, Ability>, target: Uint<32>): BattleState {
    // is there a cheap way to use these directly? TODO: test vs lookup() / insert() (probably slow)
    player_block_0 = 0;
    player_block_1 = 0;
    player_block_2 = 0;
    player_damage_0 = 0;
    player_damage_1 = 0;
    player_damage_2 = 0;
    enemy_block_0 = 0;
    enemy_block_1 = 0;
    enemy_block_2 = 0;
    enemy_damage_0 = 0;
    enemy_damage_1 = 0;
    enemy_damage_2 = 0;

    INSERT_PLAYER_BLOCK_CODE_HERE

    INSERT_PLAYER_DAMAGE_CODE_HERE
    const old_state = active_battles.lookup(disclose(derive_player_pub_key(player_secret_key()))).lookup(battle);
    return BattleState {
        old_state.deck_i,
        old_state.deck_map,
        enemy_block_0 < player_damage_0 ? (player_hp_0 + player_damage_0 - enemy_block_0) as Uint<32> : 0,
        enemy_block_1 < player_damage_1 ? (player_hp_1 + player_damage_1 - enemy_block_1) as Uint<32> : 0,
        enemy_block_2 < player_damage_2 ? (player_hp_2 + player_damage_2 - enemy_block_2) as Uint<32> : 0,
        player_block_0 < enemy_damage_0 ? (enemy_hp_0 + enemy_damage_0 - player_block_0) as Uint<32> : 0,
        player_block_1 < enemy_damage_1 ? (enemy_hp_1 + enemy_damage_1 - player_block_1) as Uint<32> : 0,
        player_block_2 < enemy_damage_2 ? (enemy_hp_2 + enemy_damage_2 - player_block_2) as Uint<32> : 0
    };
}

pure circuit effect_damage(effect: Effect, stats: EnemyStats): Uint<32> {
    return ((((effect.effect_type == EFFECT_TYPE.attack_phys) as Uint<1>) * (10 - stats.physical_def) * effect.amount + ((effect.effect_type == EFFECT_TYPE.attack_fire) as Uint<1>) * (10 - stats.fire_def) * (effect.amount)) + ((effect.effect_type == EFFECT_TYPE.attack_ice) as Uint<1>) * (10 - stats.ice_def) * effect.amount) as Uint<32>;
}

pure circuit generates_color(color: Uint<32>, ability: Ability): Boolean {
    return ability.effect.is_some && ability.effect.value.effect_type == EFFECT_TYPE.generate && ability.effect.value.amount == color;
}
