pragma language_version >= 0.12.1;

import CompactStandardLibrary;

// fire/ice can go past block
// physical doesn't
// you can either be neutral (fire/ice do normal damage) or you can have higher/lower resistances to them
// do we want them to all be 1 to 10 or just {weak fire, strong ice}/{balanced}/{strong fire, weak ice}?

export enum EFFECT_TYPE {
    attack_phys,
    attack_fire,
    attack_ice,
    block,
    generate,
}

export struct Effect {
    effect_type: EFFECT_TYPE,
    // damage for attacks, defense for blocks, type of energy for generation
    amount: Uint<32>,
    is_aoe: Boolean,
}

export struct Ability {
    effect: Maybe<Effect>,
    on_energy: Vector<3, Maybe<Effect>>,
}

export struct EnemyStats {
    hp: Uint<32>,
    // TODO: do we need a more complicated system or is this okay?
    attack: Uint<32>,
    block: Uint<32>,
    physical_def: Uint<32>,
    fire_def: Uint<32>,
    ice_def: Uint<32>,
}

// // TODO: move into an instanced battle data (unless we can compose contracts)
// export ledger enemy_damage_0: Uint<32>;
// export ledger enemy_damage_1: Uint<32>;
// export ledger enemy_damage_2: Uint<32>;
// export ledger enemy_block_0: Uint<32>;
// export ledger enemy_block_1: Uint<32>;
// export ledger enemy_block_2: Uint<32>;
// export ledger enemy_hp_0: Uint<32>;
// export ledger enemy_hp_1: Uint<32>;
// export ledger enemy_hp_2: Uint<32>;

// export ledger player_damage: Uint<32>;
// export ledger player_block: Uint<32>;
// export ledger player_hp: Uint<32>;

constructor() {
    // enemy_hp_0 = 0;
    // enemy_hp_1 = 0;
    // enemy_hp_2 = 0;
    // player_hp = 0;
}

witness player_secret_key(): Bytes<32>;

export pure circuit derive_player_pub_key(sk: Bytes<32>): Field {
    return transient_commit<Bytes<32>>(sk, 1024);
}

ledger rand_hack: Uint<32>;
circuit mock_rand_target(): Uint<0..3> {
    rand_hack = (rand_hack + 1) as Uint<32>;
    if (rand_hack > 2) {
        rand_hack = 0;
    }
    return rand_hack as Uint<0..3>;
}

// indexed by user ID then by battle ID (TODO: look up proof invalidation - are other players insulated from this by first indexing by user ID?)

// index by battle id
export ledger active_battle_states: Map<Field, BattleState>;
// index by battle id
export ledger active_battle_configs: Map<Field, BattleConfig>;

export struct Player {
    gold: Uint<32>,
    // TODO: more
}
export ledger players: Map<Field, Player>;

export struct BattleRewards {
    gold: Uint<32>;
    // what else?
}

export struct BattleConfig {
    stats: Vector<3, EnemyStats>,
    enemy_count: Uint<0..3>,
    player_pub_key: Field,
    //player_loadout_commit: Field,
    loadout: PlayerLoadout,
}

export pure circuit derive_battle_id(battle: BattleConfig): Field {
    // TODO: swap to persistent?
    return transient_commit<BattleConfig>(battle, 0);
}

export struct BattleState {
    deck_i: Uint<32>;
    deck_map: Vector<5, Uint<32>>;
    player_hp: Uint<32>;
    enemy_hp_0: Uint<32>;
    enemy_hp_1: Uint<32>;
    enemy_hp_2: Uint<32>;
}

circuit draw_ability(battle_id: Field, abilities: Vector<5, Ability>): Ability {
    const old_state = active_battle_states.lookup(battle_id);
    if (old_state.deck_i == 5) {
        shuffle(battle_id);
    }
    const i = active_battle_states.lookup(battle_id).deck_i;
    return abilities[0];
}

circuit shuffle(battle_id: Field): [] {
    const old_state = active_battle_states.lookup(battle_id);
    active_battle_states.insert(battle_id, BattleState {
        3, // TODO: randomize
        [2, 3, 4, 0, 1],// TODO: randomize
        old_state.player_hp,
        old_state.enemy_hp_0,
        old_state.enemy_hp_1,
        old_state.enemy_hp_2
    });
}

export struct PlayerLoadout {
    abilities: Vector<5, Ability>,
}

export pure circuit derive_loadout_id(loadout: PlayerLoadout): Field {
    // this line adds ~3k to the circuit
    return transient_commit<PlayerLoadout>(loadout, 100);
    //return 0 as Field;
}

export circuit start_new_battle(loadout: PlayerLoadout): BattleConfig {
    // TODO: randomize
    const player_id = disclose(derive_player_pub_key(player_secret_key()));
    const battle = BattleConfig {
        [
            EnemyStats { 30, 5, 0, 8, 5, 3 },
            EnemyStats { 25, 3, 2, 3, 8, 5 },
            EnemyStats { 15, 4, 4, 5, 3, 8 }
        ],
        3,
        player_id,
        //derive_loadout_id(loadout)
        loadout
    };
    const battle_id = derive_battle_id(battle);
    active_battle_states.insert(battle_id, init_battlestate(battle));
    active_battle_configs.insert(battle_id, battle);

    return battle;
}

pure circuit init_battlestate(battle: BattleConfig): BattleState {
    return BattleState {
        0,
        // TODO: randomize
        [0, 2, 3, 4, 1],
        100,// TODO: source from somewhere - also do we want multiple people?
        battle.stats[0].hp,
        battle.stats[1].hp,
        battle.stats[2].hp
    };
}

export circuit combat_round(/*loadout: PlayerLoadout, */battle_id: Field): Maybe<BattleRewards> {
    assert derive_player_pub_key(disclose(player_secret_key())) == active_battle_configs.lookup(battle_id).player_pub_key "Player auth failed";
    //assert derive_loadout_id(loadout) == active_battle_configs.lookup(battle_id).player_loadout_commit "Loadout hash mismatch";
    // TODO: how to cycle through abilities?
    const loadout = active_battle_configs.lookup(battle_id).loadout;
    const result = combat_round_impl(battle_id, [draw_ability(battle_id, loadout.abilities), draw_ability(battle_id, loadout.abilities), draw_ability(battle_id, loadout.abilities)], mock_rand_target());
    active_battle_states.insert(battle_id, result);
    if (result.player_hp == 0) {
        // TODO: how to handle
    } else if (result.enemy_hp_0 == 0 && result.enemy_hp_1 == 0 && result.enemy_hp_2 == 0) {
        // TODO: when and how to generate?
        const reward = BattleRewards {
            100
        };
        const player_stats = players.lookup(disclose(derive_player_pub_key(player_secret_key())));
        players.insert(disclose(derive_player_pub_key(player_secret_key())), add_player_rewards(player_stats, reward));
        return some<BattleRewards>(reward);
    }
    return none<BattleRewards>();
}

pure circuit add_player_rewards(player: Player, reward: BattleRewards): Player {
    return Player {
        (player.gold + reward.gold) as Uint<32>
    };
}

circuit combat_round_impl(battle_id: Field, abilities: Vector<3, Ability>, target: Uint<32>): BattleState {
    const battle = active_battle_configs.lookup(battle_id);
    const old_state = active_battle_states.lookup(battle_id);

    INSERT_PLAYER_BLOCK_CODE_HERE

    INSERT_PLAYER_DAMAGE_CODE_HERE

    INSERT_ENEMY_BLOCK_CODE_HERE

    INSERT_ENEMY_DAMAGE_CODE_HERE

    return BattleState {
        old_state.deck_i,
        old_state.deck_map,
        player_block < enemy_damage ? (old_state.player_hp + enemy_damage - player_block) as Uint<32> : 0,
        enemy_block_0 < player_damage_0 ? (old_state.enemy_hp_0 + player_damage_0 - enemy_block_0) as Uint<32> : 0,
        enemy_block_1 < player_damage_1 ? (old_state.enemy_hp_1 + player_damage_1 - enemy_block_1) as Uint<32> : 0,
        enemy_block_2 < player_damage_2 ? (old_state.enemy_hp_2 + player_damage_2 - enemy_block_2) as Uint<32> : 0
    };
}

export pure circuit effect_damage(effect: Effect, stats: EnemyStats): Uint<32> {
    return ((((effect.effect_type == EFFECT_TYPE.attack_phys) as Uint<1>) * (10 - stats.physical_def) * effect.amount + ((effect.effect_type == EFFECT_TYPE.attack_fire) as Uint<1>) * (10 - stats.fire_def) * (effect.amount)) + ((effect.effect_type == EFFECT_TYPE.attack_ice) as Uint<1>) * (10 - stats.ice_def) * effect.amount) as Uint<32>;
}

pure circuit generates_color(color: Uint<32>, ability: Ability): Boolean {
    return ability.effect.is_some && ability.effect.value.effect_type == EFFECT_TYPE.generate && ability.effect.value.amount == color;
}
